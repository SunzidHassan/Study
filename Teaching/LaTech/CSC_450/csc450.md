# Table of Contents
- [Table of Contents](#table-of-contents)
- [Lecture Notes](#lecture-notes)
  - [Chapter 1: Computer Networks and the Internet](#chapter-1-computer-networks-and-the-internet)
    - [1.5 Protocol Layers and Their Service Models](#15-protocol-layers-and-their-service-models)
      - [The Application Layer](#the-application-layer)
      - [Transport Layer](#transport-layer)
      - [Network layer](#network-layer)
      - [Link Layer](#link-layer)
      - [Physical Layer](#physical-layer)
      - [Lecture](#lecture)
  - [Chapter 2: Application Layer](#chapter-2-application-layer)
    - [2.1 Principles of Network Application](#21-principles-of-network-application)
    - [2.2 The Web and HTTP](#22-the-web-and-http)
      - [2.2.1 Overview of HTTP](#221-overview-of-http)
      - [2.2.2 Non-Persistent and Persistent Connections](#222-non-persistent-and-persistent-connections)
      - [2.2.3 HTTP Message Format](#223-http-message-format)
      - [2.2.4 User-Server Interaction: Cookies](#224-user-server-interaction-cookies)
      - [2.2.5 Web Caching](#225-web-caching)
    - [2.3 Electronic Mail in the Internet](#23-electronic-mail-in-the-internet)
    - [2.4 DNS--The Internet's Directory Service](#24-dns--the-internets-directory-service)
    - [2.5 Peer-to-Peer Applications](#25-peer-to-peer-applications)
    - [2.6 Video Streaming and Content Distribution Networks](#26-video-streaming-and-content-distribution-networks)
    - [2.7 Socket Programming: Creating Network Applications](#27-socket-programming-creating-network-applications)
  - [Chapter 3: Transport Layer](#chapter-3-transport-layer)
    - [3.1 Introduction and Transport-Layer Services](#31-introduction-and-transport-layer-services)
    - [3.2 Multiplexing and Demultiplexing](#32-multiplexing-and-demultiplexing)
    - [3.3 Connectionless Transport: UDP](#33-connectionless-transport-udp)
    - [3.4 Principles of Reliable Data Transfer](#34-principles-of-reliable-data-transfer)
    - [3.5 Connection-Oriented Transport: TCP](#35-connection-oriented-transport-tcp)
    - [3.6 Principles of Congestion Control](#36-principles-of-congestion-control)
    - [3.7 TCP Congestion Control](#37-tcp-congestion-control)
  - [Chapter 4: The Network Layer: Data Plane](#chapter-4-the-network-layer-data-plane)
  - [Chapter 5: The Network Layer: Control Plane](#chapter-5-the-network-layer-control-plane)
  - [Chapter 6: The Link Layer and LANs](#chapter-6-the-link-layer-and-lans)
  - [Chapter 7: Wireless and Mobile Networks](#chapter-7-wireless-and-mobile-networks)
  - [Chapter 8: Security in Computer Networks](#chapter-8-security-in-computer-networks)
- [Labs](#labs)
  - [Lab 1: spot delay using wireshark](#lab-1-spot-delay-using-wireshark)
    - [Dr. Tahat Session](#dr-tahat-session)
  - [Lab 2](#lab-2)
  - [Lab 3](#lab-3)
  - [Lab 4](#lab-4)
  - [Lab 5](#lab-5)
- [Projects](#projects)
  - [Project 1](#project-1)
  - [Project 2](#project-2)

# Lecture Notes
## Chapter 1: Computer Networks and the Internet

### 1.5 Protocol Layers and Their Service Models
#### The Application Layer
is where network applications and their application-layer protocols reside.
Protocols:
- HTTP (which provides for Web
document request and transfer),
- SMTP (which provides for the transfer of e-mail messages),
- FTP (which provides for the transfer of files between two end systems).
- DNS (URL to 32-bit network address)

End systems use application-layer protocol to distribute packets of information called '**message**'.

#### Transport Layer
Transports application-layer messages between application endpoints.

Two transport protocols:
- **TCP**: reliable
  - provides a connection-oriented service to its applications.
  - This service includes guaranteed delivery of application-layer messages to the destination, flow and congestion control, etc.
- **UDP**: speed
  - The UDP protocol provides a connectionless service to its applications. This is a no-frills service that provides no reliability, no flow control, and no congestion control.

A transport-layer packet is a **segment**.

#### Network layer
responsible for moving network-layer packets known as **datagrams** from one host to another.

Transport-layer protocol in a source host passes a transport-layer segment and a destination address to the network layer. The network layer then provides the service of delivering the segment to the transport layer in the destination host.

Protocol:
- IP - defines the fields in the datagram as well as how the end systems and routers act on these fields. There is only one IP protocol, and all Internet components that have a network layer must run the IP protocol.

- Routing protocols - determine the routes that datagrams take between sources and destinations. The Internet has many routing protocols.

#### Link Layer
Routes a datagram through a series of routers between the source and destination.
At each node, the network layer passes the datagram down to the link layer, which delivers the datagram to the next node's network layer.

Services:
- reliable delivery: (different from TCP - one end system to another)

Protocols:
Ethernet
WiFi
cable access network’s DOCSIS protocol.

A datagram may be handled by different link-layer protocols at different links along its route.

Link-layer packets are **frames**.

#### Physical Layer
To move the individual bits within the frame from one node to the next.

Protocols: 
- depends on link, and actual transmission medium of the link (twisted-pair copper wire, single-mode fiber optics).
In each case, a bit is moved across the link in a different way.

#### Lecture
Down the stack - encapsulation, down the stack - decapsulation.

**Application layer**
- PDU **messages** (binary data, interpreted using file extensions).
- Protocols: running proccess follows **HTTP, HTTPS, DNS, SMTP, FTP**, etc. protocols.

**Transport layer**
- process-process logical connection
- PDU - **segments**
  - segmented data-efficiency,
  - multiplexing--multiple communication
- adds source and destination port address (process-process)
- protocol: **TCP** (reliable) or **UDP** (speed).

**Network layer**
- host-host logical connection
- PDU - **datagrams**
- adds source and destination host address (IP address).
- protocol: **IP**

**Link Layer**
- node to node logical connection
- PDU - **frames**.
- protocols: Ethernet, WiFi, etc.
- source and destination link address

**Physical Layer**
- physical connection.
- convert bits into signals.

**OSI Model**:
- Application
  - Application
  - Presentation: encryption
  - Session: establish, maintain and terminate communication session


## Chapter 2: Application Layer
### 2.1 Principles of Network Application

**Process communicating**
Program running within a host
- client process: initiates communication
- server process: waits to be contacted

### 2.2 The Web and HTTP
#### 2.2.1 Overview of HTTP

#### 2.2.2 Non-Persistent and Persistent Connections

#### 2.2.3 HTTP Message Format
**Format:**
Method: GET URL Protocol
Header: accepted content, language, compression, character set, persistent connection
Body

**Other HTTP request messages**:
- GET: (no body in request) (body in response).
  - Example: retrieve the current weather for a specific city.
- POST: (body in request that contains data) – creates new resource in client.
  - Example: Add weather data about a new city.
- HEAD: (no body in request) (no body in response)
- PUT: (body in request) – create or modify existing resource in a URL.
  - Example: update all weather data about a specific city.

**HTTP response message**:
- Status line: status code and phrase
- Header: Contains info of the content, connection.
- Body

**HTTP response status codes**: 200 OK and 404 Not Found

#### 2.2.4 User-Server Interaction: Cookies
HTTP GET/response interaction is **stateless**: server doesn’t sore information about previous client requests.

**Maintaining user/server state**: cookies
1. When a server wants to track a user, it includes a special header in HTTP response.
2. Client browser will keep a cookie (including sessionID) file.
3. Future request message headers will include the sessionID.
4. Server backend database will keep user info.


#### 2.2.5 Web Caching
Browser sends all HTTP requests to cache
- If object in cache: cache returns object to client
- Else cache requests object from origin server, caches received object, then returns object to client

Cache: both client and server
Benefits:
- Closer to user so faster response
- Reduce outgoing traffic


### 2.3 Electronic Mail in the Internet


### 2.4 DNS--The Internet's Directory Service
Network layer transport datagrams from host to host using 32-bit IP-address. But we use easy to remember 'names'.

**Domain Name System**
Application-layer protocol: hosts and name servers (distributed database) communicate to resolve address-name translation.

**DNS Service**
- Hostname to IP address translation -> initiate TCP connection.
- A host with complicated hostname or mail server can have one or more alias names.
- Load distribution: busy sites have multiple servers, their cname is associated with a set of IP addresses. DNS rotation of the set with each response distributes the load among the servers.

Why not centralized DNS
- Single point of failure
- traffic
- distance
- scale

**Distributed, hierarchical DB**: root name server > Top-level domain server (.com) > Authoritative DNS server (amazon.com) > IP address.
Local DNS name servers: ISP

Iterated query: replies with name of server to contact.
Recursive query: contacted server resolves name.

**Caching**: TDL mapping in local name servers for TTL time.

**DNS records**
DB storing resource records (RR).
Format
  - name, 
  - value, 
  - type
    - A-IP,
    - CNAME-real name,
    - NS-domain,
    - MX-mailserver
  - ttl

**DNS protocol messages**
- 12 byte header
  - 2 byte identifier
  - flags
    - 1 bit query/reply
    - 1 bit autoritative server
    - 1 bit recursion desired
    - ...
  - Quesion info: queried name, type
  - Answer: type, value, TTL - single or multiple.

**Inserting records into DNS**
- DNS registrar inserts NS, A RRs into TLD server: (networkutopia.com, dns1.networkutopia.com, NS)
(dns1.networkutopia.com, 212.212.212.1, A)
- Create autoritative server locally with IP


### 2.5 Peer-to-Peer Applications


### 2.6 Video Streaming and Content Distribution Networks


### 2.7 Socket Programming: Creating Network Applications
Door between application processes  and end-end-transport protocol.

Two socket for two transport service:
- TCP - reliable
- UDP - fast

**Socket programming with TCP**
Client
- contacts server
  - creates TCP socket
  - specifies server IP, port number of process
- establish connection

Server
- creates new socket for server process to communicate with the client

- Sender attaches destination IP with each packet, extracted by receiver.
- transmissed data may be lost or out of order.


## Chapter 3: Transport Layer
### 3.1 Introduction and Transport-Layer Services

- Provide logical communication (complex route in reality) between application processes (e.g., client and server) running on different hosts.
- implemented in end systems

App-layer packet **messages**
-> breakdown and add header
-> Transport-layer packet **segments**
-> Network-layer packet **datagram** - routers interact only with Network-layer fields of datagram
-> receiver-end Network-layer passes segment to Transport-layer
-> receiver-end Transport-layer compiles message from segments and passes to application layer.

Transport layer provides logical-communication between processes, network layer provides logical-communication between hosts.

Analogy:
12 kids in Ann’s house sending letters to 12 kids in Bill’s house:
hosts = houses
processes = kids
app messages = letters in envelopes
transport protocol = Ann and Bill who demux to in-house siblings
network-layer protocol = postal service


### 3.2 Multiplexing and Demultiplexing
Transport layer receives/delivers data from/to sockets. Each socket has an unique identifier - each segment has fields to identify right socket.

**Multiplexing**
  - gathering data chunks from different sockets
  - encapsulating each with header info (source-dest. IP addresses, source-dest. port numbers) to create segments,
  - passing segments to network layer.
**Demultiplexing**
  - delivering data  in a segment to the correct socket using header info (source-dest. IP addresses, source-dest. port numbers).

This extends host-to-host delivery service provided by network layer to a process-to-process delivery service by applications on a host.

### 3.3 Connectionless Transport: UDP

### 3.4 Principles of Reliable Data Transfer

rdt_send()
udt_send()
rdt_rcv()
deliver_data()

Finite State Machines: event/actions

rdt1.0: reliable data transfer over a reliable channel
- sender: rdt_send(data)/(udt_send(packet=make_pkt))
- receiver: rdt_rcv(packet)/(deliver_data(extract(packet,data)))

rdt2.0:channel with bit errors
checksum to detect bit error
- ACKs: pkt received OK
- NAKs: pkt had errors -> retransmit

sender: 
rdt_send(data):
    sndpkt=make_pkt(data,checksum)
    udt_send(sndpkt)
- if rdt_rcv(rcvpkt) && isNAK(rcvpkt):
  - udt_send(sndpkt)
- elif rdt_rcv(rcvpkt) && isACK(rcvpkt):
  - next

receiver:
- if rdt_rcv(rcvpkt) && corrupt(rcvpkt):
  - udt_send(NAK)
- elif rdt_rcv(rcvpkt) && notcorrupt(rcvpkt):
  - extract(rcvpkt, data)
  - deliver_data(data)
  - udt_send(ACK)

If ACK/NAK is corrupted -> retransmit current pkt with seq+1

Receiver discards duplicate pkt

rdt_send(data):
    sndpkt=make_pkt(0,data,checksum)
    udt_send(sndpkt)
- if rdt_rcv(rcvpkt) && corrupt(rcvpkt) || isNAK(rcvpkt):
  - udt_send(sndpkt):
    sndpkt=make_pkt(1,data,checksum)
    udt_send(sndpkt)
- elif rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && isACK(rcvpkt):
  - next
- elif 

rdt3.0:channels with errors and loss

sender waits "reasonable" amount of time for ACK
- retransmits if no ACK received

### 3.5 Connection-Oriented Transport: TCP
TCP is "connection-oriented" - two processes must first "handshake" before exchanging data.
**Flow control**
- Network layer delivers IP datagram payload into TCP socket buffers. Application removes data from TCP socket buffers.
- Receiver "advertises" free buffer with `rwnd`, so sender won't overflow receiver's buffer.

**TCP connection management**
Sender/receiver "handshake" before data exchange.

2-way handshake problem
- half-open connection
- duplicate data acceptance due to lag.

3-way handshake
Syn bit=1, Seq=x
Synbit=1, ACKbit=1, ACKnum, Seq=y
ACKbit=1, ACKnum=y+1

Closing connection:
Client and Server: FIN bit=1.
Respond to received FIN with ACK

### 3.6 Principles of Congestion Control

### 3.7 TCP Congestion Control

## Chapter 4: The Network Layer: Data Plane


## Chapter 5: The Network Layer: Control Plane


## Chapter 6: The Link Layer and LANs


## Chapter 7: Wireless and Mobile Networks


## Chapter 8: Security in Computer Networks


# Labs
## Lab 1: spot delay using wireshark
Lab Instructions: Network Traffic & Delay Analysis with Wireshark

Part 1: Setup and Installation
1.  **Download and Install:** Download Wireshark from the [official website](https://www.wireshark.org/download.html). Wireshark is the industry-standard tool for network traffic analysis.
2.  **Launch:** Open Wireshark. You will see a list of networks available for capture.
    > **⚠️ CRITICAL WARNING:** Do not capture live traffic on the university network (LaTech)! We will strictly use the provided trace file for this assignment.
3.  **Load the Data:** Open the provided `Lab1.pcap` file. You will see approximately 12,000 packets load into the main window.

Part 2: Understanding the Interface
Wireshark is divided into three main default panes. Take a moment to familiarize yourself with them:

* **Packet List (Top Pane):** Each row represents a single captured packet. Columns display the Packet Number (Serial), Relative Time, Source/Destination IPs, Protocol, and Length.
* **Packet Details (Bottom-Left Pane):** This shows the protocol stack (encapsulation) for the selected packet. You can expand each layer to see details:
    * `Frame`: Link Layer (Ethernet/MAC)
    * `Internet Protocol`: Network Layer (IP addressing)
    * `Transmission Control Protocol`: Transport Layer (Ports/Seq Numbers)
    * `Hypertext Transfer Protocol`: Application Layer (Data)
* **Packet Bytes (Bottom-Right Pane):** Displays the raw hexadecimal data.
    * *Tip:* You can view a visual structure instead of raw bytes by going to **Edit > Preferences > Layout** and selecting "Packet Diagram" for pane 3.

Part 3: High-Level Analysis
Before digging into delays, get an overview of the traffic:

1.  **Identify the Client:** In this specific trace file, the client device IP is **192.168.10.108**.
2.  **View Conversations:** Go to **Statistics > Conversations**. This window summarizes traffic volume between endpoints at different layers:
    * **Ethernet:** Link layer (MAC addresses).
    * **IPv4/IPv6:** Network layer (IPv4 uses 32-bit addresses; IPv6 uses 128-bit addresses).
    * **TCP/UDP:** Transport layer.
3.  **Basic Filtering:** You can filter for specific protocols. Type `http` in the display filter bar at the top (it turns green if the syntax is correct) and hit **Enter**. This filters the view to show only HTTP web traffic.

Part 4: Configuring for Delay Analysis
To find network lag, we need to customize our view to show the time difference between packets.

1.  **Adjust Cache Settings:** To ensure all packets are sorted correctly, go to **Edit > Preferences > Appearance** and ensure "Maximum number of cached rows" is set to at least **20,000**.
2.  **Add the Delta Column:**
    * Select any **TCP** packet in the top pane.
    * In the **Packet Details** pane, expand the **Transmission Control Protocol** arrow.
    * Expand **Timestamps**.
    * Right-click on **Time since previous frame in this TCP stream**.
    * Select **Apply as Column**.
3.  **Rename the Column:**
    * Right-click the header of the new column you just created.
    * Select **Edit Column**.
    * Change the title to **"TCP Delta"**.

Part 5: Investigating Server-Side Delays
We are specifically looking for delays originating from the server.

1.  **Identify the Server:** Locate packets involving the server IP **184.85.75.86**.
2.  **Isolate the Conversation:** Right-click on any packet involving this server IP and select **Conversation Filter > TCP**. This removes unrelated background noise.
3.  **Analyze the Handshake:**
    * Click the **"No."** (Serial) header to sort by packet number.
    * Find the first three packets. These represent the **3-Way Handshake** (`[SYN]`, `[SYN, ACK]`, `[ACK]`).
    * Observe the sequence numbers and flags in the Packet Details pane to understand how the connection started.
4.  **Find the Lag:**
    * Click the new **TCP Delta** column header to sort the packets by time.
    * Look for the highest values. These represent the longest pauses between packets in the stream.
    * *Note:* Do not worry about *why* the delay happened for now; your goal is simply to identify *where* it happened.

Part 6: Submission Requirements
1.  **Screenshot:** Take a clear screenshot of the packet list showing the packet with the high "TCP Delta" value.
2.  **Write-up:** Briefly describe the process you followed to configure Wireshark and find the high-delay packet.
3.  **Submit:** Upload your document to Canvas.
TCP Delta

High (server-side) TCP Delta Conversation:
TCP 3-way handshake
Syn bit=1, Seq=x
Synbit=1, ACKbit=1, ACKnum, Seq=y
ACKbit=1, ACKnum=y+1



### Dr. Tahat Session

Tracefile: stores log data

pcap (packet capture) or pcapng (newer with more metadata).

Capture and store network traffic as pcap files using tools like Wireshark.

Capture frames (first packet-encapsulates lower level encapsulations)

Wireshark introduction:
- Interface: 3 main windows
  - list of packets - each packet in a row - info like time, source, destination, ...
  - layer information in lower left
  - lower right: actual data (hexadecimal) - encapsulation

Captured traffic contains diverse packet data types simultaneously: TCP, HTTP, DNS, etc.

We'll define a column called delta time to spot delay.

Select a TCP packet > TCP > SEQ/ACK analysis > RTT to ACK the segment was > Right click and select `Apply as column` > Rename the column as Delta

Alternatively: Edit Column - Name as Delta - Field: tcp.time_delta

TCP > Timestamps > Time since the previous frame > Apply as Column > Rename as TCP Delta

Anything with source 108 is client
source of 86 is server

We're interested in delay from server - the user can be delayed due to natural reasons.

sort by No., right click on source packet > Conversation filter > TCP

At first you should see the three way handshake

+++++++++++
Segment Len 0 is acknowledgement, >0 is sending

We'd like to calculate the avg. RTT is TCP Delta - we want to focus on packets with high TCP Delta.

Take screenshot of any >10 seconds packet

Preferences > Appearance > Layout > max number of cached rows (20000)

Question: TCP Delta vs Delta


## Lab 2
## Lab 3
## Lab 4
## Lab 5


# Projects
## Project 1
## Project 2